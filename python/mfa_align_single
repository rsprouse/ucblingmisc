#!/usr/bin/env python

# A wrapper for running mfa_align on a single file.

import os
import shutil
import sys
import re
from tempfile import TemporaryDirectory
import subprocess

standard_usage_str = '''
Safely run `mfa_align` on a single audio file.

Usage:

mfa_align_single [mfa_align options] wavfile transcript_extension 
    dictionary_path acoustic_model_path output_textgrid
'''
help_usage_str = '''multi_align_single --help|-h'''

def usage():
    print('\n' + standard_usage_str)
    print(help_usage_str + '\n')

def help():
    print(standard_usage_str)
    print(help_usage_str + '\n')
    print('''
`mfa_align_single` creates a temporary 'corpus' of a single audio file
and related transcription, runs `mfa_align` on the 'corpus', and moves the
result from a temporary output directory to a specified output directory. 
The temporary directories are created in a way so that it is safe to run
multiple instances of `mfa_align_single` in parallel safely without name
clashes.

The `mfa_align` command is specified by the environment variable
$MFA_ALIGN_CMD. If that variable is not set or empty, then `mfa_align`
must be found in $PATH.
'''
    )
    print('''

Parameters
----------

wavfile
The name of the input audio file to be aligned.

transcript (full filename or extension only)
The transcript file to be aligned to the input audio file. If this value
is '.TextGrid', '.lab', or '.txt', then it is interepreted as a filename
extension that replaces the '.wav' portion of the `wavfile` value. For example,
if `wavfile` is `mydir/words.wav` and `transcript` is `.lab`, then
`mydir/words.lab` will be used as the transcript file. ('.txt' files are
submitted to `mfa_align` as if they were '.lab' files.)

dictionary_path
The `dictionary_path` value to pass to `mfa_align`.

acoustic_model_path
The `acoustic_model_path` value to pass to `mfa_align`.

output_textgrid
The name of the output textgrid.

Options
-------

Options are passed to `mfa_align`. See `mfa_align --help` for a list of
available options. The `-t TEMP_DIRECTORY` option should not be used
since `mfa_align_single` supplies its own value for this option. The
`-j NUM_JOBS` option also should not be used since `mfa_align_single`
always sets this value to 1.
'''
    )

numargs = 5
if '-t' in sys.argv[1:-numargs]:
    raise RuntimeError('-t `mfa_align` option must not be used')
if '-j' in sys.argv[1:-numargs]:
    raise RuntimeError('-j `mfa_align` option must not be used')

try:
    if sys.argv[1] in ('-h', '--help'):
        sys.exit(help())
    wavfile, trans_ext, dictpath, lang, out_tg = sys.argv[-numargs:]
    wavfname = os.path.split(wavfile)[-1]
    if trans_ext in ('.TextGrid', '.lab', '.txt'):
        transfile = re.sub('\.wav$', trans_ext, wavfile, re.IGNORECASE)
    else:
        transfile = trans_ext
        trans_ext = os.path.splitext(transfile)[-1]
    if trans_ext == '.txt':
        trans_ext = '.lab'
    trname = re.sub('\.wav$', trans_ext, wavfname)
except (IndexError, ValueError):
    sys.exit(usage())
envvar = os.getenv('MFA_ALIGN_CMD')
align_cmd = envvar if envvar is not None and envvar != '' else 'mfa_align'
cmdlist = [align_cmd] + sys.argv[1:-numargs]

# Create symlinks to the input audio and transcription files in the
# temporary corpus directory.
with TemporaryDirectory() as corpdir:
    os.symlink(os.path.abspath(wavfile), os.path.join(corpdir, wavfname))
    os.symlink(os.path.abspath(transfile), os.path.join(corpdir, trname))
    # Create a temporary dir for mfa to write results to,
    # then copy output textgrid to out_tg.
    with TemporaryDirectory() as tmp_mfa_outdir:
        # mfa_align creates its own temporary dir, and we pass
        # in a premade dir to use.
        with TemporaryDirectory() as mfa_tmpdir:
            cmdlist += [
                '-j', '1',
                '-t', mfa_tmpdir,
                corpdir, dictpath, lang, tmp_mfa_outdir
            ]
            result = subprocess.run(cmdlist, capture_output=True)
            m = re.search('(?P<logfile>[^ ]+/corpus.log)', result.stdout.decode('ascii'))
            if m is not None:
                with open(m.groupdict()['logfile'], 'r') as logh:
                    content = logh.readlines()
                print('Log says:\n', content, '\n\n')
            print('mfa_align stdout:\n', result.stdout.decode('utf-8'))
            print('mfa_align stderr:\n', result.stderr.decode('utf-8'))
            mfa_tg = os.path.abspath(
                os.path.join(
                    tmp_mfa_outdir,
                    os.path.basename(os.path.normpath(corpdir)),
                    re.sub('\.wav$', '.TextGrid', wavfname, re.IGNORECASE)
                )
            )
            shutil.copy2(mfa_tg, out_tg)
            # TODO copy output textgrid to out_tg; what about oovs_found.txt?
